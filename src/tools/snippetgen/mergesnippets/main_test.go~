package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"reflect"
	"testing"

	"google3/apiserving/vkit/tools/snippetgen/fragment"
)

func TestFlags(t *testing.T) {
	fmt.Printf("primaryLocation: %q", *primaryLocation)

	tempDir, err := ioutil.TempDir("", "merge_test")
	if err != nil {
		t.Fatalf("could not create tempdir")
	}
	defer func(path string) {
		if err := os.RemoveAll(path); err != nil {
			t.Fatalf("could not RemoveAll(%q)", path)
		}
	}(tempDir)

	apiName := "harvest"
	apiVersion := "v12"
	apiMethod := "harvest.field.read"

	primaryFragment := fragment.Info{
		Path: fragment.Path{
			APIName:      apiName,
			APIVersion:   apiVersion,
			APIRevision:  "",
			FragmentName: apiMethod,
			Lang:         metadata.FragmentLanguage,
		},
		File: fragment.File{
			Format:      "0.314",
			APIName:     apiName,
			APIVersion:  apiVersion,
			APIRevision: "371",
			ID:          apiMethod,
			CodeFragment: map[string]*CodeFragment{
				"Java": &CodeFragment{
					GenerationVersion: "gv11",
					GenerationDate:    "today",
					Fragment:          "// A Java Sample",
				},
				Libraries: []*fragment.LibraryInfo{
					&fragment.LibraryInfo{
						URL:  "foo.com",
						Name: "The FooJava client library",
					},
				},
			},
		},
	}

	secondaryFragment := fragment.Info{
		Path: fragment.Path{
			APIName:      apiName,
			APIVersion:   apiVersion,
			APIRevision:  "7",
			FragmentName: apiMethod,
			Lang:         metadata.FragmentLanguage,
		},
		File: fragment.File{
			Format:      "0.314",
			APIName:     apiName,
			APIVersion:  apiVersion,
			APIRevision: "7",
			ID:          apiMethod,
			CodeFragment: map[string]*CodeFragment{
				"Python": &CodeFragment{
					GenerationVersion: "89",
					GenerationDate:    "last week",
					Fragment:          "# A Python sample",
				},
				Libraries: []*fragment.LibraryInfo{
					&fragment.LibraryInfo{
						URL:  "bar.edu",
						Name: "The BarPython client library",
					},
				},
			},
		},
	}

	mergedFragment := secondaryFragment // placeholder

	*primaryLocation = path.Join(tempDir, "primary")
	*secondaryLocation = path.Join(tempDir, "secondary")
	*mergedLocation = path.Join(tempDir, "merged")

	if err := primaryFragment.ToFile(*primaryLocation, false); err != nil {
		t.Fatalf("could not write to primary location %q: %s\nFragment:\n%#v", *primaryLocation, err, primaryFragment)
	}

	if err := secondaryFragment.ToFile(*secondaryLocation, false); err != nil {
		t.Fatalf("could not write to secondary location %q: %s\nFragment:\n%#v", *secondaryLocation, err, secondaryFragment)
	}

	actualMergedFilename := path.Join(*mergedLocation, apiVersion, "317", apiMethod)
	actualMerged, err := fragment.FromFile(actualMergedFilename)
	if err != nil {
		t.Errorf("could not load merged fragment %q", actualMergedFilename)
	}

	if !reflect.DeepEqual(merged, actualMerged) {
		t.Errorf("merge error:\ngot:\n%#v\nwant:\n%#v", actualMerged, merged)
	}
}
