package fragment

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"gapi-tools/tools/snippetgen/mergesnippets/util"
)

// FromFile parses the file at 'filePath' into an Info struct that it
// returns. The 'filePath' itself is also used to extract the metadata
// for the Info struct.
func FromFile(filePath string) (*Info, error) {
	components := strings.Split(filePath, string(os.PathSeparator))
	num := len(components)
	if num < 4 {
		return nil, fmt.Errorf("too few components in path %q", filePath)
	}
	path := Path{
		apiName:      components[num-4],
		apiVersion:   components[num-3],
		apiRevision:  components[num-2],
		fragmentName: components[num-1],
	}

	if !strings.HasSuffix(path.fragmentName, util.FragmentFileSuffix) {
		return nil, fmt.Errorf("did not find extension %q in file %q", util.FragmentFileSuffix, filePath)
	}

	contents, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("error reading file %q: %s", filePath, err)
	}

	var file File
	if err := json.Unmarshal(contents, &file); err != nil {
		return nil, fmt.Errorf("error unmarshalling JSON from %q: %s", filePath, err)
	}

	fragmentInfo := &Info{
		Path: &path,
		File: &file,
	}
	return fragmentInfo, nil
}

// ToFile writes 'info' into the appropriate file in a path root at
// 'rootPath'. If 'markCurrent' is set, it overrides the path to have
// a current revision marker (rather than whatever revision is
// contained in Info).
func (info *Info) ToFile(rootPath string, markCurrent bool) error {
	const filePermissions = 0440
	const directoryPermissions = 0750
	if info == nil || info.Path == nil {
		return fmt.Errorf("no metadata available")
	}

	path := info.Path
	revision := path.apiRevision
	if markCurrent {
		revision = util.CurrentRevision
	}
	filePath := filepath.Join(rootPath, path.apiName, path.apiVersion, revision, path.fragmentName)
	directory, _ := filepath.Split(filePath)

	if err := os.MkdirAll(directory, directoryPermissions); err != nil {
		return fmt.Errorf("error creating directory %q: %s", directory, err)
	}

	fragmentJSON, err := json.Marshal(info.File)
	if err != nil {
		return fmt.Errorf("error while marshalling JSON : %s", err)
	}

	if err := ioutil.WriteFile(filePath, fragmentJSON, filePermissions); err != nil {
		return fmt.Errorf("error writing file %q: %s", filePath, err)
	}

	return nil
}
