package fragment

import (
	"gapi-tools/tools/snippetgen/mergesnippets/util"
	"testing"
)

func TestCheckLanguages(t *testing.T) {
	info := &Info{Path: &Path{}, File: &File{}}

	// No languages should fail validation.
	if got, want := info.CheckLanguages() == nil, false; got != want {
		t.Errorf("no code samples fails CheckLanguages: got: %v, want: %v", got, want)
	}

	// No languages should fail validation.
	info.File.CodeFragment = make(map[string]*CodeFragment)
	if got, want := info.CheckLanguages() == nil, false; got != want {
		t.Errorf("no code samples fails CheckLanguages: got: %v, want: %v", got, want)
	}

	// An unrecognized languages should fail validation
	info.File.CodeFragment["foo language"] = &CodeFragment{Fragment: "sample"}
	if got, want := info.CheckLanguages() == nil, false; got != want {
		t.Errorf("invalid language fails CheckLanguages: got: %v, want: %v", got, want)
	}

	// Excluding exactly one of the required languages should fail validation
	for _, excludedLanguage := range util.RequiredLanguages {
		info.File.CodeFragment = make(map[string]*CodeFragment)
		for _, language := range util.RequiredLanguages {
			if language != excludedLanguage {
				info.File.CodeFragment[language] = &CodeFragment{Fragment: "sample"}
			}
		}
		if got, want := info.CheckLanguages() == nil, false; got != want {
			t.Errorf("missing required language %q fails CheckLanguages: got: %v, want: %v", excludedLanguage, got, want)
		}
	}

	info.File.CodeFragment = make(map[string]*CodeFragment)
	for _, language := range util.RequiredLanguages {
		info.File.CodeFragment[language] = &CodeFragment{Fragment: "sample"}
	}
	// Having all the required languages only should pass validation
	if got, want := info.CheckLanguages() == nil, true; got != want {
		t.Errorf("having just the required languages passes CheckLanguages: got: %v, want: %v", got, want)
	}

	// Having all the required languages and an unknown language should fail validation
	info.File.CodeFragment["foo language"] = &CodeFragment{Fragment: "sample"}
	if got, want := info.CheckLanguages() == nil, false; got != want {
		t.Errorf("having the required languages plus a disallowed language fails CheckLanguages: got: %v, want: %v", got, want)
	}

}

func TestMergeWith(t *testing.T) {
	cases := []struct {
		first, second, merged *Info
		error                 bool
	}{
		{
			first:  &Info{File: &File{Format: "1"}},
			second: &Info{File: &File{Format: "1"}},
		},
		{
			first:  &Info{Processed: true},
			second: &Info{},
			error:  true,
		},
		{
			first:  &Info{},
			second: &Info{Processed: true},
			error:  true,
		},
		{
			first:  &Info{},
			second: nil,
		},
		{
			first:  &Info{File: &File{Format: "one"}},
			second: &Info{File: &File{Format: "one"}},
		},
		{
			first:  &Info{Path: &Path{}, File: &File{Format: "one"}},
			second: &Info{Path: &Path{}, File: &File{Format: "two"}},
			error:  true,
		},
		{
			first:  &Info{Path: &Path{}, File: &File{Format: "1", APIVersion: "v23"}},
			second: &Info{Path: &Path{}, File: &File{Format: "1", APIVersion: "v24"}},
			error:  true,
		},
		{
			first:  &Info{File: &File{Format: "1", APIRevision: "5", CodeFragment: map[string]*CodeFragment{"Java": &CodeFragment{Fragment: "the first"}}}},
			second: &Info{File: &File{Format: "1", APIRevision: "7", CodeFragment: map[string]*CodeFragment{"Java": &CodeFragment{Fragment: "the second"}}}},
			merged: &Info{File: &File{Format: "1", APIRevision: "5~7", CodeFragment: map[string]*CodeFragment{"Java": &CodeFragment{Fragment: "the first"}}}},
		},
		{
			first:  &Info{File: &File{Format: "1", APIRevision: "5", CodeFragment: map[string]*CodeFragment{"Java": &CodeFragment{Fragment: "hello, world", GenerationVersion: "2"}}}},
			second: &Info{File: &File{Format: "1", APIRevision: "7", CodeFragment: map[string]*CodeFragment{"Java": &CodeFragment{Fragment: "hello, world", GenerationVersion: "3"}}}},
			merged: &Info{File: &File{Format: "1", APIRevision: "5~7", CodeFragment: map[string]*CodeFragment{"Java": &CodeFragment{Fragment: "hello, world", GenerationVersion: "2"}}}},
		},
	}
	for idx, test := range cases {
		merged, err := test.first.MergeWith(test.second)
		if got, want := (err != nil), test.error; got != want {
			t.Errorf("%d: error encountered: got: %v, want: %v.\n   first: %#v\n   second: %#v\n\n", idx, got, want, test.first, test.second)
		}

		if test.merged == nil {
			continue
		}
		if got, want := merged.File.APIRevision, test.merged.File.APIRevision; got != want {
			t.Errorf("%d: unexpected revision: got: %q, want: %q.\n   first: %#v\n   second: %#v\n\n", idx, got, want, *test.first, *test.second)
		}
		if got, want := len(merged.File.CodeFragment), len(test.merged.File.CodeFragment); got != want {
			t.Errorf("%d: unexpected number of code fragments: got: %d, want: %d\n   first: %#v\n   second: %#v\n\n", idx, got, want, *test.first, *test.second)
		}
		for tk, tv := range test.merged.File.CodeFragment {
			mv, found := merged.File.CodeFragment[tk]
			if !found {
				t.Errorf("%d: code fragment for %q expected but not found.\n   first: %#v\n   second: %#v\n\n", idx, tk, *test.first, *test.second)
				continue
			}
			areEqual := (tv.GenerationVersion == mv.GenerationVersion &&
				tv.GenerationDate == mv.GenerationDate &&
				tv.Fragment == mv.Fragment &&
				len(tv.Libraries) == len(mv.Libraries))
			if got, want := *mv, *tv; !areEqual {
				t.Errorf("%d: code fragment for %q:\n   got: %#v\n   want: %#v.\n   first: %#v\n   second: %#v\n\n", idx, tk, got, want, *test.first, *test.second)
			}
		}
	}
}

func TestHasConsistentMetadata(t *testing.T) {
	cases := []struct {
		info       Info
		consistent bool
	}{
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix}, File: &File{}}, consistent: true},
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix, apiName: "alice"}, File: &File{APIName: "bob"}}, consistent: false},
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix, apiVersion: "1"}, File: &File{APIName: "2"}}, consistent: false},
		{info: Info{Path: &Path{fragmentName: "foo.frag.json"}, File: &File{ID: "bar"}}, consistent: false},
		{info: Info{Path: &Path{fragmentName: "foo.frag.json"}, File: &File{ID: "foo"}}, consistent: true},
		{info: Info{Path: &Path{fragmentName: "foo"}, File: &File{ID: "foo"}}, consistent: false},
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix, apiRevision: "1"}, File: &File{APIRevision: "2"}}, consistent: false},

		// Various combinations of the revision identifiers.
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix}, File: &File{APIRevision: "0"}}, consistent: true},
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix, apiRevision: "0"}, File: &File{APIRevision: "0"}}, consistent: true},
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix}, File: &File{}}, consistent: true},
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix, apiRevision: "0"}, File: &File{}}, consistent: true},

		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix}, File: &File{APIRevision: "1"}}, consistent: false},
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix, apiRevision: "1"}, File: &File{APIRevision: "0"}}, consistent: false},
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix, apiRevision: "0"}, File: &File{APIRevision: "1"}}, consistent: false},
		{info: Info{Path: &Path{fragmentName: util.FragmentFileSuffix, apiRevision: "1"}, File: &File{}}, consistent: false},
	}

	for idx, test := range cases {
		if got, want := test.info.HasConsistentMetadata(), test.consistent; got != want {
			t.Errorf("%d: CheckForConsistency: got %v, want %v.\nPath: %#v\nFile: %#v\n\n", idx, got, want, test.info.Path, test.info.File)
		}
	}
}

func TestAreCommensurate(t *testing.T) {
	cases := []struct {
		first        *File
		second       *File
		commensurate bool
	}{
		{
			first:        nil,
			second:       nil,
			commensurate: false,
		},
		{
			first:        nil,
			second:       &File{},
			commensurate: false,
		},
		{
			first:        &File{},
			second:       nil,
			commensurate: false,
		},
		{
			first:        &File{},
			second:       &File{},
			commensurate: true,
		},
		{
			first: &File{
				Format:       "one",
				ID:           "some.id",
				APIName:      "random name",
				APIVersion:   "v21",
				APIRevision:  "23",
				CodeFragment: map[string]*CodeFragment{"list": &CodeFragment{}},
			},
			second: &File{
				Format:       "one",
				ID:           "some.id",
				APIName:      "random name",
				APIVersion:   "v21",
				APIRevision:  "23",
				CodeFragment: map[string]*CodeFragment{"delete": &CodeFragment{}},
			},
			commensurate: true,
		},
		{
			first:        &File{Format: "one"},
			second:       &File{Format: "two"},
			commensurate: false,
		},
		{
			first:        &File{ID: "some.id"},
			second:       &File{ID: "other.id"},
			commensurate: false,
		},
		{
			first:        &File{APIName: "random name"},
			second:       &File{APIName: "deliberate name"},
			commensurate: false,
		},
		{
			first:        &File{APIVersion: "v21"},
			second:       &File{APIVersion: "v210000"},
			commensurate: false,
		},
		{
			first:        &File{APIRevision: "23"},
			second:       &File{APIRevision: "230000"},
			commensurate: true,
		},
	}

	for idx, test := range cases {
		if got, want := AreCommensurate(test.first, test.second), test.commensurate; got != want {
			t.Errorf("%d: AreCommensurate( %#v,  %#v): got %v, want %v", idx, test.first, test.second, got, want)
		}
	}
}
